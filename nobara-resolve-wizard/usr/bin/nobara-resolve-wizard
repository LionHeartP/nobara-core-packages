#!/usr/bin/python3

import gi
import zipfile
import os
import pwd
import subprocess
import shutil
import sys
import threading

gi.require_version("Gtk", "3.0")
gi.require_version("GLib", "2.0")
gi.require_version("Flatpak", "1.0")

from gi.repository import Gtk, GLib

class DaVinciInstaller(Gtk.Application):
    def __init__(self):
        super().__init__(application_id="org.nobaraproject.policykit.davinciresolve.wizard.install")
        self.window = None
        settings = Gtk.Settings.get_default()
        settings.set_property("gtk-theme-name", "adw-gtk3-dark")  # Replace with the exact theme name if different
        settings.set_property("gtk-application-prefer-dark-theme", True)

    def do_activate(self):
        if self.window:
            self.window.present()
            return

        # App window
        self.window = Gtk.ApplicationWindow(application=self)
        self.window.set_default_size(520, 340)
        self.window.set_position(Gtk.WindowPosition.CENTER)
        self.window.set_border_width(0)
        self.window.set_resizable(False)

        # HeaderBar
        hb = Gtk.HeaderBar()
        hb.set_show_close_button(True)
        hb.props.title = "DaVinci Resolve"
        hb.props.subtitle = "Installer & Updater"
        # Optional: app icon if you have one
        # hb.pack_start(Gtk.Image.new_from_icon_name("applications-multimedia", Gtk.IconSize.BUTTON))
        self.window.set_titlebar(hb)

        # Main content
        self.build_ui()

        # Optional CSS polish
        self.apply_css()

        self.window.show_all()

    def build_ui(self):
        outer = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=8)
        self.window.add(outer)

        # Card-like container
        card = Gtk.Frame()
        card.set_shadow_type(Gtk.ShadowType.IN)
        card.get_style_context().add_class("card")
        card.set_margin_left(16)
        card.set_margin_right(16)
        card.set_margin_top(16)
        card.set_margin_bottom(16)
        outer.pack_start(card, True, True, 0)

        card_box = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=12)
        card_box.set_border_width(16)
        card.add(card_box)

        # Instructions
        instruction = Gtk.Label()
        instruction.set_line_wrap(True)
        instruction.set_line_wrap_mode(Gtk.WrapMode.WORD_CHAR)
        instruction.set_xalign(0.0)
        instruction.set_halign(Gtk.Align.CENTER)
        instruction.set_markup(
            "Download the latest installer from Blackmagic:"
        )
        card_box.pack_start(instruction, False, False, 0)

        # Link row
        row = Gtk.Box(orientation=Gtk.Orientation.HORIZONTAL, spacing=8)
        row.set_halign(Gtk.Align.CENTER)
        card_box.pack_start(row, False, False, 0)

        link = Gtk.LinkButton(
            uri="https://www.blackmagicdesign.com/products/davinciresolve",
            label="Open DaVinci Resolve Download Page",
        )
        link.set_halign(Gtk.Align.CENTER)
        row.pack_start(link, False, False, 0)

        # Instructions
        instruction2 = Gtk.Label()
        instruction2.set_line_wrap(True)
        instruction2.set_line_wrap_mode(Gtk.WrapMode.WORD_CHAR)
        instruction2.set_xalign(0.0)
        instruction2.set_halign(Gtk.Align.CENTER)
        instruction2.set_markup(
            "Then select the downloaded <i>.zip</i>:"
        )
        card_box.pack_start(instruction2, False, False, 0)

        row2 = Gtk.Box(orientation=Gtk.Orientation.HORIZONTAL, spacing=8)
        row2.set_halign(Gtk.Align.CENTER)
        card_box.pack_start(row2, False, False, 0)
        select_btn = Gtk.Button.new_with_label("Select Downloaded ZIP…")
        select_btn.get_style_context().add_class("suggested-action")
        select_btn.connect("clicked", self.on_file_select)
        select_btn.set_halign(Gtk.Align.CENTER)
        row2.pack_start(select_btn, False, False, 0)

        # Status area with spinner (hidden by default)
        status_row = Gtk.Box(orientation=Gtk.Orientation.HORIZONTAL, spacing=8)
        status_row.set_halign(Gtk.Align.CENTER)
        self.spinner = Gtk.Spinner()
        self.spinner.set_halign(Gtk.Align.CENTER)
        self.spinner.stop()
        self.spinner.set_no_show_all(True)  # we toggle visibility
        status_row.pack_start(self.spinner, False, False, 0)

        self.status_label = Gtk.Label(label="")
        self.status_label.set_xalign(0.0)
        status_row.pack_start(self.status_label, True, True, 0)
        card_box.pack_start(status_row, False, False, 4)

        # Footer hints
        footer = Gtk.Label()
        footer.set_xalign(0.0)
        footer.set_margin_left(18)
        footer.set_margin_right(18)
        footer.set_margin_bottom(10)
        footer.set_use_markup(True)
        footer.set_markup(
            "<small>Tip: Keep the window open during installation. "
            "You’ll get a pop-up when it completes.</small>"
        )
        outer.pack_end(footer, False, False, 0)

    def apply_css(self):
        css = b"""
        .card {
            border-radius: 12px;
            /* Remove hardcoded background color */
            /* background: #f8f9fb; */
            padding: 8px;
            border-width: 0;        /* remove visible border */
            box-shadow: none;       /* if theme adds shadows */
        }
        .card > * {
            border-radius: 12px;
            border-width: 0;        /* remove visible border */
            box-shadow: none;       /* if theme adds shadows */
        }
        """
        provider = Gtk.CssProvider()
        provider.load_from_data(css)
        screen = self.window.get_screen()
        Gtk.StyleContext.add_provider_for_screen(
            screen, provider, Gtk.STYLE_PROVIDER_PRIORITY_APPLICATION
        )

    def on_file_select(self, widget):
        dialog = Gtk.FileChooserDialog(
            title="Select ZIP File",
            parent=self.window,
            action=Gtk.FileChooserAction.OPEN,
        )
        dialog.add_buttons(
            Gtk.STOCK_CANCEL, Gtk.ResponseType.CANCEL,
            Gtk.STOCK_OPEN, Gtk.ResponseType.OK
        )

        filter_zip = Gtk.FileFilter()
        filter_zip.set_name("ZIP files")
        filter_zip.add_pattern("*.zip")
        dialog.add_filter(filter_zip)

        response = dialog.run()
        if response == Gtk.ResponseType.OK:
            zip_path = dialog.get_filename()
            dialog.destroy()  # Close the file chooser dialog

            # Check if libfuse is installed
            subprocess.run(["ldconfig", "-p"], check=True,
                        stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
            if not (os.path.exists("/lib64/libfuse.so.2") or os.path.exists("/usr/lib64/libfuse.so.2")):

                # If not, install fuse-libs
                install_process = subprocess.run(
                    ["pkexec", "dnf", "install", "-y", "fuse-libs"],
                    check=True,
                    stdout=subprocess.PIPE,
                    stderr=subprocess.PIPE,
                    text=True
                )
                # Tell user if there's an error
                if install_process.returncode != 0:
                    GLib.idle_add(
                        self.show_error_dialog,
                        f"Failed to install fuse-libs: {install_process.stderr}. "
                        "Please run 'sudo dnf install fuse-libs' manually."
                    )
                    return

            # ⚠️ Run installer on main thread (it will spawn worker thread internally)
            self.run_installer(zip_path)

        else:
            dialog.destroy()

    def run_installer(self, zip_path):
        """
        Runs on the GTK main thread.
        - Shows inline status (spinner/label if present).
        - Spawns a worker thread that does the heavy lifting in extract_and_install().
        - Does NOT block the UI; completion is handled by on_install_complete()
        which the worker must call via GLib.idle_add(...).
        """
        # Prepare for cleanup later (we'll delete this in on_install_complete)
        self._cleanup_path = os.path.join(os.path.dirname(zip_path), "resolve_wizard_extracted")

        # Optional UX: show status if you added spinner/label in your UI
        if hasattr(self, "spinner") and self.spinner:
            self.spinner.set_visible(True)
            self.spinner.start()
        if hasattr(self, "status_label") and self.status_label:
            self.status_label.set_text("Running DaVinci Resolve installer…")

        # Make sure only one worker at a time
        if getattr(self, "_worker_thread", None) and self._worker_thread.is_alive():
            # Already running; you could show a dialog if you want
            return

        # Launch the worker (no UI in the worker!)
        self._worker_thread = threading.Thread(
            target=self.extract_and_install, args=(zip_path,), daemon=True
        )
        self._worker_thread.start()


    def run_nobara_resolved_pkexec(self, run_file):
        def run_command():
            try:
                subprocess.run(
                    ["pkexec", "/usr/libexec/nobara-resolve-pkexec", run_file],
                    stdout=subprocess.DEVNULL,
                    stderr=subprocess.DEVNULL,
                    check=True
                )

            except subprocess.CalledProcessError as e:
                # schedule UI work on the main loop
                GLib.idle_add(self.on_install_complete, False, f"Nobara Resolve installation failed: {e}")
                return

        # Start the command in a separate thread
        thread = threading.Thread(target=run_command)
        thread.start()

        # Wait for the thread to complete
        thread.join(timeout=300)  # Set a timeout of 5 minutes

        if thread.is_alive():
            self.show_error_dialog("The installation process timed out. Please check your internet connection and try again.")

    def on_install_complete(self, success, status=None):
        """
        Runs on the GTK main thread (must be invoked via GLib.idle_add from the worker).
        - Stops inline status.
        - Cleans up the extracted temp dir.
        - Shows a success or error dialog.
        """
        # Stop status indicators
        if hasattr(self, "spinner") and self.spinner:
            self.spinner.stop()
            self.spinner.set_visible(False)
        if hasattr(self, "status_label") and self.status_label:
            self.status_label.set_text("")

        # Cleanup extracted working directory if we tracked it
        cleanup_path = getattr(self, "_cleanup_path", None)
        if cleanup_path:
            try:
                shutil.rmtree(cleanup_path)
            except Exception as e:
                # Non-fatal; log to stdout/stderr
                print(f"Cleanup error: {e}")

        # Show final result
        if success:
            self.show_success_dialog("DaVinci Resolve installed successfully!")
        else:
            self.show_error_dialog(
                f"An error occurred during DaVinci Resolve installation. {status or ''}"
            )


    def extract_and_install(self, zip_path):
        # Helper to finish on the main thread and stop further work in this function
        def fail(msg):
            GLib.idle_add(self.on_install_complete, False, msg)

        try:
            # 1) Extract ZIP to a temp working dir next to the ZIP
            extract_path = os.path.join(os.path.dirname(zip_path), "resolve_wizard_extracted")
            try:
                with zipfile.ZipFile(zip_path, 'r') as zip_ref:
                    zip_ref.extractall(extract_path)
            except zipfile.BadZipFile:
                fail("The selected file is not a valid ZIP archive.")
                return
            except Exception as e:
                fail(f"Failed to extract ZIP: {e}")
                return

            # 2) Locate the .run installer inside the extracted contents
            run_file = None
            for root, dirs, files in os.walk(extract_path):
                for file in files:
                    if file.endswith(".run"):
                        run_file = os.path.join(root, file)
                        break
                if run_file:
                    break

            if not run_file:
                fail("No .run file found in the extracted contents.")
                return

            # 3) Run the privileged installer via pkexec (blocking is OK; we're in a worker thread)
            try:
                subprocess.run(
                    ["pkexec", "/usr/libexec/nobara-resolve-pkexec", run_file],
                    stdout=subprocess.DEVNULL,
                    stderr=subprocess.PIPE,
                    text=True,
                    check=True,
                )
            except subprocess.CalledProcessError as e:
                fail(f"Installer failed (pkexec): {e.stderr.strip() or e}")
                return
            except Exception as e:
                fail(f"Unable to launch installer with pkexec: {e}")
                return

            # 4) Copy the desktop shortcut to the user's Desktop
            try:
                shortcut_file = "/usr/share/applications/com.blackmagicdesign.resolve.desktop"
                user_home = os.path.expanduser("~")
                desktop_path = os.path.join(user_home, "Desktop")
                os.makedirs(desktop_path, exist_ok=True)
                shutil.copy2(shortcut_file, desktop_path)
            except FileNotFoundError:
                fail("Desktop shortcut not found at /usr/share/applications/com.blackmagicdesign.resolve.desktop.")
                return
            except Exception as e:
                fail(f"Failed to copy desktop shortcut: {e}")
                return

            # 5) Bypass the onboarding screen by writing the version flag
            try:
                config_dir = os.path.join(user_home, ".local", "share", "DaVinciResolve", "configs")
                os.makedirs(config_dir, exist_ok=True)
                version_file = os.path.join(config_dir, ".version")
                with open(version_file, "w") as f:
                    f.write("Onboarding.Version=100000")
            except Exception as e:
                fail(f"Failed to write onboarding config: {e}")
                return

            # 6) If we made it here, everything succeeded
            GLib.idle_add(self.on_install_complete, True, None)

        finally:
            # Optional: leave cleanup to run_installer() if it's already handling it.
            # If you prefer to clean here, wrap with try/except and don't call UI from this block.
            pass


    def show_success_dialog(self, message):
        dialog = Gtk.MessageDialog(
            transient_for=self.window,
            destroy_with_parent=True,
            message_type=Gtk.MessageType.INFO,
            buttons=Gtk.ButtonsType.OK,
            text=message,
        )
        dialog.connect("response", self.on_dialog_response, dialog)
        dialog.show_all()

    def show_error_dialog(self, message):
        dialog = Gtk.MessageDialog(
            transient_for=self.window,
            flags=0,
            message_type=Gtk.MessageType.ERROR,
            buttons=Gtk.ButtonsType.CLOSE,
            text="Error",
        )
        dialog.format_secondary_text(message)
        dialog.run()
        dialog.destroy()

    def on_dialog_response(self, widget, response_id, dialog):
        if response_id == Gtk.ResponseType.OK:
            if self.window:
                self.window.destroy()
            Gtk.main_quit()
        dialog.destroy()

if __name__ == "__main__":
    DaVinciInstaller().run(None)
