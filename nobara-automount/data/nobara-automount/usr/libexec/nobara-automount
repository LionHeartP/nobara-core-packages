#!/usr/bin/bash
set -euo pipefail

log() { echo "[nobara-automount] $*"; }

if [[ ${USER:-} != "liveuser" ]]; then
  if [[ $EUID -ne 0 ]]; then
    if ! id -nG "${USER}" | grep -qw wheel; then
      log "User ${USER} is not in wheel group. Non-admin users cannot mount drives. Exiting."
      exit 0
    fi
    target_user="${RWUSER:-$USER}"
    log "Re-executing via pkexec for user ${USER}…"
    exec pkexec env RWUSER="${target_user}" "$(realpath "$0")" -- "$@"
  fi

  UUID_FILTER=""
  DO_CLEANUP=0
  MOUNTPOINT=""
  UNIT_ARG=""
  FSTYPE=""
  DO_PRE_RESET=0

  # NEW: prefer RWUSER env (written by your GUI)
  rwuser="${RWUSER:-${SUDO_USER:-${USER}}}"

  # Parse flags first
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --uuid) UUID_FILTER="$2"; shift 2;;
      --mountpoint) UNIT_ARG="$2"; shift 2;;
      --mount) DO_CLEANUP=0; shift;;
      --cleanup) DO_CLEANUP=1; shift;;
      --fstype) FSTYPE="$2"; shift 2;;
      --reset) DO_PRE_RESET=1; shift;;
      *)  # keep compatibility if GUI ever passes the user positionally
          if [[ -z "${rwuser}" || "${rwuser}" == "root" ]]; then rwuser="$1"; fi
          shift;;
    esac
  done

  # If we were given a mount *unit* name, turn it into a filesystem path
  # e.g. run-media-tcrider-<UUID>.mount  ->  /run/media/tcrider/<UUID>
  if [[ -n "$UNIT_ARG" && "$UNIT_ARG" == *.mount ]]; then
    MOUNTPOINT="$(echo "$UNIT_ARG" | sed 's/\.mount$//')"
  fi

  if [[ -z "$UUID_FILTER" && -n "$MOUNTPOINT" ]]; then
    UUID_FILTER="$(basename "$MOUNTPOINT")"
  fi

  if [[ -z "${rwuser}" ]]; then
    log "Could not determine target user for mounts."
    exit 1
  fi

  if [[ "$DO_CLEANUP" == "1" ]]; then
    [[ -z "$UUID_FILTER" ]] && exit 0
    mp="/run/media/${rwuser}/${UUID_FILTER}"
    if [[ -f /etc/nobara/automount/desktop_shortcuts.conf ]]; then
      if ! grep -Fq "$UUID_FILTER" /etc/nobara/automount/desktop_shortcuts.conf; then
        log "Skipping desktop shortcut creation for $mp not in desktop_shortcuts.conf"
        [[ -z "$UUID_FILTER" ]] && exit 0
        desktop_dir="$(getent passwd "$rwuser" | cut -d: -f6)/Desktop"

        # loop over all .desktop files and check contents for UUID_FILTER
        for f in "$desktop_dir"/*.desktop; do
            [[ -e "$f" ]] || continue   # skip if no matches
            if grep -q "$UUID_FILTER" "$f"; then
                rm -f "$f"
            fi
        done
      fi
    else
      log "desktop_shortcut.conf not found; skipping desktop shortcut creation for $mp"
      [[ -z "$UUID_FILTER" ]] && exit 0
      desktop_dir="$(getent passwd "$rwuser" | cut -d: -f6)/Desktop"

      # loop over all .desktop files and check contents for UUID_FILTER
      for f in "$desktop_dir"/*.desktop; do
          [[ -e "$f" ]] || continue   # skip if no matches
          if grep -q "$UUID_FILTER" "$f"; then
              rm -f "$f"
              break   # stop after first match (remove this if you want to delete all matches)
          fi
      done
    fi
    if ! mountpoint -q -- "$mp" && [ -d "$mp" ] && [ -z "$(ls -A -- "$mp")" ]; then
        rmdir -- "$mp" 2>/dev/null || true
    fi
    exit 0
  fi

  RW_UID="$(id -u "$rwuser")"
  RW_GID="$(id -g "$rwuser")"
  log "Mounts will be owned by ${rwuser} (uid=${RW_UID}, gid=${RW_GID})."

  post_mount_fixup_unix_fs() {
    log "Setting mount permissions for ext*/btrfs/xfs"
    local dev="/dev/disk/by-uuid/${UUID_FILTER}"
    # Find the live mountpoint for this device (fallback to your default path)
    local mp
    mp="$(findmnt -n -o TARGET --source "$dev" 2>/dev/null)" || true
    [[ -z "$mp" ]] && mp="/run/media/${rwuser}/${UUID_FILTER}"
    log "Mount point reported: $mp"
    # Wait up to 30s for the mountpoint to appear
    for i in {1..30}; do
      if mountpoint -q -- "$mp"; then
        break
      fi
      sleep 1
    done

    # If still not mounted after 5s, nothing to do
    if ! mountpoint -q -- "$mp"; then
      log "Error: No partition mounted at $mp"
      return 1
    fi
    log "Mount point found: $mp"
    # Detect filesystem type actually mounted there
    local fstype
    fstype="${FSTYPE}" || true
    [[ -z "$fstype" ]] && fstype="$(blkid -o value -s TYPE "$dev" 2>/dev/null)" || true
    log "Found fstype: $fstype"
    case "$fstype" in
      ext3|ext4|btrfs|xfs)
        # Resolve UID/GID
        local uid gid
        if [[ -n "$RW_UID" && -n "$RW_GID" ]]; then
          uid="$RW_UID"; gid="$RW_GID"
        else
          uid="$(id -u "$RWUSER")"; gid="$(id -g "$RWUSER")"
        fi

        # If already owned correctly, skip
        local cur_owner
        cur_owner="$(stat -c '%u:%g' -- "$mp" 2>/dev/null || echo ':')"
        if [[ "$cur_owner" != "${uid}:${gid}" ]]; then
          chown "$uid:$gid" -- "$mp" || true
        fi

        # Ensure directory is writable by owner (don’t relax group/world more than needed)
        chmod u+rwx,go+rx -- "$mp" || true

        # Optional: give the user default ACLs so *new* subdirs/files are user-writable
        # setfacl -m u:${uid}:rwx -d -m u:${uid}:rwx -- "$mp" || true
        ;;
      *)
        log "non-UNIX FS $fstype should be handled via mount options uid=/gid=/umask="
        ;;
    esac
  }

  preflight_reset_mount() {
    local mp="/run/media/${rwuser}/${UUID_FILTER}"
    local unit="$(systemd-escape -p --suffix=mount "$mp")"

    systemctl reset-failed "$unit" 2>/dev/null || true

    rm -f "/run/systemd/transient/$unit" 2>/dev/null || true
    systemctl daemon-reload
    mkdir -p "$mp" 2>/dev/null || true
  }

  if [[ "$DO_PRE_RESET" == "1" ]]; then
    log "Performing pre-mount reset."
    preflight_reset_mount
    log "Performed pre-mount reset."
    exit 0
  fi

  # Enumerate candidate partitions
  while IFS= read -r line; do
    uuid="$(awk '{print $2}' <<<"$line")"

    [[ -n "$uuid" ]] || continue

    if [[ -n "$UUID_FILTER" && "$DO_PRE_RESET" == "0" && "$uuid" != "$UUID_FILTER" ]]; then
      continue
    fi
    post_mount_fixup_unix_fs

    partition_name="$uuid"

    # -------------------------------------------------------------------

    MP="/run/media/$rwuser/$partition_name"
    UNIT="$(systemd-escape -p --suffix=mount "$MP")"
    pretty="$uuid"
    label="$(blkid -o value -s LABEL "/dev/disk/by-uuid/$uuid" 2>/dev/null || true)"
    [[ -n "$label" ]] && pretty="$label"

    user_home="$(getent passwd "$rwuser" | cut -d: -f6)"
    desktop_dir="${user_home}/Desktop"
    mp="/run/media/${rwuser}/${uuid}"
    url="file://${mp}"
    icon_path="${desktop_dir}/${pretty}.desktop"

    resolve_model_for_base() {
      local base="$1" name="" model=""
      name="$(lsblk -b -P -o PKNAME,UUID,MODEL | grep $base | cut -d " " -f 1 | cut -d "=" -f 2 | sed 's/"//g')"
      parent="$(lsblk -no PKNAME "/dev/$name" | head -n1 2>/dev/null)"
      model="$(lsblk -dn -o MODEL "/dev/$parent" 2>/dev/null)"

      # If not luks encrypted then the parent is the name.
      if [[ -z $model ]]; then
        model="$(lsblk -dn -o MODEL "/dev/$name" 2>/dev/null)"
      fi
      printf '%s\n' "$model"
    }

    # 1) size like "7.3T"
    dev="$(readlink -f "/dev/disk/by-uuid/$uuid")"
    model=""
    model="$(resolve_model_for_base "$uuid")"
    log "$model"

    size_str="$(lsblk -dno SIZE "$dev" 2>/dev/null)"

    [[ -z "$size_str" ]] && size_str="${label:-$uuid}"

    # Escape '.' for regex use
    size_re="${size_str//./\\.}"

    # 2) collect used numbers for this size across existing desktop shortcuts
    declare -A used=()
    shopt -s nullglob
    for f in "$desktop_dir"/*.desktop; do
        [[ -e "$f" ]] || continue   # skip if no matches
        if grep -q "$UUID_FILTER" "$f"; then
            exit 0   # stop after first match (remove this if you want to delete all matches)
        fi
    done
    for f in "$desktop_dir"/*.desktop; do
      [[ "$f" == "$icon_path" ]] && continue   # ignore our own file when (re)creating
      name_line="$(grep -m1 '^Name=' "$f" 2>/dev/null | cut -d= -f2-)"
      if [[ "$name_line" =~ ^${size_re}\ Disk\ ([0-9]+)$ ]]; then
        used["${BASH_REMATCH[1]}"]=1
      fi
    done
    # 3) pick the smallest free N>=1
    n=1
    while :; do
      [[ -z "${used[$n]+x}" ]] && break
      ((n++))
    done
    pretty="${size_str} Disk ${n}"

    # If our UUID file already exists and already has a matching "size Disk N"
    # that's not taken by others, keep it (avoid renumbering on replug)
    if [[ -f "$icon_path" ]]; then
      current_name="$(grep -m1 '^Name=' "$icon_path" 2>/dev/null | cut -d= -f2-)"
      if [[ "$current_name" =~ ^${size_re}\ Disk\ ([0-9]+)$ ]]; then
        currn="${BASH_REMATCH[1]}"
        if [[ -z "${used[$currn]+x}" ]]; then
          pretty="$current_name"
        fi
      fi
    fi

    if [[ -n "$model" ]]; then
      pretty="$pretty ($model)"
    fi
    icon_path="${desktop_dir}/${pretty}.desktop"
    # 4) write/update the .desktop (filename stays <uuid>.desktop)
    tmp="$(mktemp)"
    cat > "$tmp" <<EOF
[Desktop Entry]
Type=Link
Name=${pretty}
Icon=drive-removable-media
URL=file:///run/media/${rwuser}/${uuid}
EOF
    install -o "$RW_UID" -g "$RW_GID" -m 0644 "$tmp" "$icon_path"
    rm -f "$tmp"

  log "Created desktop icon '${pretty}.desktop' (owner $rwuser)."

  done < <(lsblk -rno TYPE,UUID,FSTYPE,MOUNTPOINT | awk '$1=="part"||$1=="crypt"{print}')
fi
