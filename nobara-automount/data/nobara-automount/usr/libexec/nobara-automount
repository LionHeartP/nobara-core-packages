#!/usr/bin/bash
set -euo pipefail

log() { echo "[nobara-automount] $*"; }

if [[ ${USER:-} != "liveuser" ]]; then
  if [[ $EUID -ne 0 ]]; then
    if ! id -nG "${USER}" | grep -qw wheel; then
      log "User ${USER} is not in wheel group. Non-admin users cannot mount drives. Exiting."
      exit 0
    fi
    target_user="${RWUSER:-$USER}"
    log "Re-executing via pkexec for user ${USER}…"
    exec pkexec env RWUSER="${target_user}" "$(realpath "$0")" -- "$@"
  fi

  UUID_FILTER=""
  DO_CLEANUP=0
  MOUNTPOINT=""
  UNIT_ARG=""
  DO_PRE_RESET=0

  # NEW: prefer RWUSER env (written by your GUI)
  rwuser="${RWUSER:-${SUDO_USER:-${USER}}}"

  # Parse flags first
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --uuid) UUID_FILTER="$2"; shift 2;;
      --mountpoint) UNIT_ARG="$2"; shift 2;;
      --mount) DO_CLEANUP=0; shift;;
      --cleanup) DO_CLEANUP=1; shift;;
      --reset) DO_PRE_RESET=1; shift;;
      *)  # keep compatibility if GUI ever passes the user positionally
          if [[ -z "${rwuser}" || "${rwuser}" == "root" ]]; then rwuser="$1"; fi
          shift;;
    esac
  done

  # If we were given a mount *unit* name, turn it into a filesystem path
  # e.g. run-media-tcrider-<UUID>.mount  ->  /run/media/tcrider/<UUID>
  if [[ -n "$UNIT_ARG" && "$UNIT_ARG" == *.mount ]]; then
    MOUNTPOINT="$(echo "$UNIT_ARG" | sed 's/\.mount$//')"
  fi

  if [[ -z "$UUID_FILTER" && -n "$MOUNTPOINT" ]]; then
    UUID_FILTER="$(basename "$MOUNTPOINT")"
  fi

  if [[ -z "${rwuser}" ]]; then
    log "Could not determine target user for mounts."
    exit 1
  fi

  if [[ "$DO_CLEANUP" == "1" ]]; then
    [[ -z "$UUID_FILTER" ]] && exit 0
    mp="/run/media/${rwuser}/${UUID_FILTER}"
    desktop_dir="$(getent passwd "$rwuser" | cut -d: -f6)/Desktop"

    # loop over all .desktop files and check contents for UUID_FILTER
    for f in "$desktop_dir"/*.desktop; do
        [[ -e "$f" ]] || continue   # skip if no matches
        if grep -q "$UUID_FILTER" "$f"; then
            rm -f "$f"
            break   # stop after first match (remove this if you want to delete all matches)
        fi
    done
    rmdir "$mp" 2>/dev/null || true
    exit 0
  fi

  RW_UID="$(id -u "$rwuser")"
  RW_GID="$(id -g "$rwuser")"
  log "Mounts will be owned by ${rwuser} (uid=${RW_UID}, gid=${RW_GID})."

  get_mount_opts() {
    local fstype="$1"
    local devpath="$2"
    local opts=""
    case "$fstype" in
      ext4|xfs|ext3|ext2)
        opts="rw,noatime,lazytime"
        ;;
      f2fs)
        if [[ ! -f /etc/filesystems ]] || ! grep -q '\bf2fs\b' /etc/filesystems; then
          echo "f2fs" >> /etc/filesystems
        fi
        opts="rw,noatime,lazytime,compress_algorithm=zstd,compress_chksum,atgc,gc_merge"
        ;;
      btrfs)
        opts="rw,noatime,lazytime,compress-force=zstd,space_cache=v2,autodefrag,ssd_spread"
        local tmpmp="/run/media/${rwuser}/.btrfs_probe.$$"
        mkdir -p "$tmpmp"
        if mount -t btrfs -o ro "$devpath" "$tmpmp" 2>/dev/null; then
          local sub="@"
          if [[ -d "$tmpmp/$sub" ]] && btrfs subvolume show "$tmpmp/$sub" &>/dev/null; then
            opts+=",subvol=${sub}"
          fi
          umount -l "$tmpmp" || true
        fi
        rmdir "$tmpmp" 2>/dev/null || true
        ;;
      vfat)
        opts="rw,noatime,lazytime,uid=${RW_UID},gid=${RW_GID},utf8=1"
        ;;
      exfat)
        opts="rw,noatime,lazytime,uid=${RW_UID},gid=${RW_GID}"
        ;;
      ntfs)
        # FUSE ntfs-3g → drop unsupported options
        opts="rw,noatime,lazytime,uid=${RW_UID},gid=${RW_GID},big_writes,umask=0022"
        ;;
      *)
        opts="rw,noatime,lazytime"
        ;;
    esac
    printf '%s' "$opts"
  }

  preflight_reset_mount() {
    local mp="/run/media/${rwuser}/${UUID_FILTER}"
    local unit="$(systemd-escape -p --suffix=mount "$mp")"

    systemctl reset-failed "$unit" 2>/dev/null || true

    rm -f "/run/systemd/transient/$unit" 2>/dev/null || true
    systemctl daemon-reload
    mkdir -p "$mp" 2>/dev/null || true
  }

  if [[ "$DO_PRE_RESET" == "1" ]]; then
    log "Performing pre-mount reset."
    preflight_reset_mount
    log "Performed pre-mount reset."
    exit 0
  fi

  # Enumerate candidate partitions
  while IFS= read -r line; do
    typ="$(awk '{print $1}' <<<"$line")"
    uuid="$(awk '{print $2}' <<<"$line")"
    fstype="$(awk '{print $3}' <<<"$line")"
    mntp="$(awk '{print $4}' <<<"$line")"

    [[ "$typ" == "part" ]] || continue
    [[ -n "$uuid" ]] || continue
    [[ -z "$mntp" ]] || continue
    [[ "$fstype" != "crypto_LUKS" ]] || continue

    partition_name="$uuid"
    tomount="/dev/disk/by-uuid/$partition_name"
    [[ -n "$fstype" ]] || continue

    [[ -n "$UUID_FILTER" && "$uuid" != "$UUID_FILTER" ]] && continue

    # ---- Relaxed allow-list check (matches your original behavior) ----
    if [[ -f /etc/nobara/automount/enabled.conf ]]; then
      if ! grep -Fq "$partition_name" /etc/nobara/automount/enabled.conf; then
        log "Skipping $partition_name ($fstype): not in enabled.conf"
        continue
      fi
    else
      log "enabled.conf not found; skipping $partition_name (preserving original behavior)"
      continue
    fi
    # -------------------------------------------------------------------

    if [[ "$fstype" == "ntfs" ]]; then
      ntfsfix "$tomount" &>/dev/null || true
    fi

    mountopts="$(get_mount_opts "$fstype" "$tomount")"

    MP="/run/media/$rwuser/$partition_name"
    UNIT="$(systemd-escape -p --suffix=mount "$MP")"

    pretty="$uuid"
    label="$(blkid -o value -s LABEL "/dev/disk/by-uuid/$uuid" 2>/dev/null || true)"
    [[ -n "$label" ]] && pretty="$label"

    user_home="$(getent passwd "$rwuser" | cut -d: -f6)"
    desktop_dir="${user_home}/Desktop"
    mp="/run/media/${rwuser}/${uuid}"
    url="file://${mp}"
    icon_path="${desktop_dir}/${pretty}.desktop"

    if [[ -d "$desktop_dir" ]]; then
      # 1) size like "7.3T"
      dev="$(readlink -f "/dev/disk/by-uuid/$uuid")"

      # Get the parent whole device (strip partition suffix)
      parent="$(lsblk -no PKNAME -- "$dev" 2>/dev/null)"

      # Get the size of the parent device (e.g. 256G)
      if [[ -n "$parent" ]]; then
        size_str="$(lsblk -dno SIZE "/dev/$parent" 2>/dev/null)"
      else
        # fallback: just query this node
        size_str="$(lsblk -dno SIZE "$dev" 2>/dev/null)"
      fi
      [[ -z "$size_str" ]] && size_str="${label:-$uuid}"

      # Escape '.' for regex use
      size_re="${size_str//./\\.}"

      # 2) collect used numbers for this size across existing desktop shortcuts
      declare -A used=()
      shopt -s nullglob
      for f in "$desktop_dir"/*.desktop; do
        [[ "$f" == "$icon_path" ]] && continue   # ignore our own file when (re)creating
        name_line="$(grep -m1 '^Name=' "$f" 2>/dev/null | cut -d= -f2-)"
        if [[ "$name_line" =~ ^${size_re}\ Disk\ ([0-9]+)$ ]]; then
          used["${BASH_REMATCH[1]}"]=1
        fi
      done

      # 3) pick the smallest free N>=1
      n=1
      while :; do
        [[ -z "${used[$n]+x}" ]] && break
        ((n++))
      done
      pretty="${size_str} Disk ${n}"

      # If our UUID file already exists and already has a matching "size Disk N"
      # that's not taken by others, keep it (avoid renumbering on replug)
      if [[ -f "$icon_path" ]]; then
        current_name="$(grep -m1 '^Name=' "$icon_path" 2>/dev/null | cut -d= -f2-)"
        if [[ "$current_name" =~ ^${size_re}\ Disk\ ([0-9]+)$ ]]; then
          currn="${BASH_REMATCH[1]}"
          if [[ -z "${used[$currn]+x}" ]]; then
            pretty="$current_name"
          fi
        fi
      fi

      dev="/dev/disk/by-uuid/$uuid"
      node="$(readlink -f -- "$dev")"
      parent="$(lsblk -no PKNAME -- "$node" 2>/dev/null)"

      model=""
      if [[ -n "$parent" ]]; then
        # Query the whole-disk node
        model="$(lsblk -no MODEL -- "/dev/$parent" 2>/dev/null)"
      fi

      # Fallback: udev property (works for partitions too)
      if [[ -z "$model" ]]; then
        model="$(udevadm info --query=property --name="$node" 2>/dev/null \
                | sed -n 's/^ID_MODEL=//p')"
      fi

      # Normalize a bit
      model="${model//_/ }"                      # underscores -> spaces (common on NVMe)
      model="$(sed 's/[[:space:]]\+$//' <<<"$model")"   # trim trailing space

      if [[ -n "$model" ]]; then
        pretty="$pretty ($model)"
      fi
      icon_path="${desktop_dir}/${pretty}.desktop"
      # 4) write/update the .desktop (filename stays <uuid>.desktop)
      tmp="$(mktemp)"
      cat > "$tmp" <<EOF
[Desktop Entry]
Type=Link
Name=${pretty}
Icon=drive-removable-media
URL=file:///run/media/${rwuser}/${uuid}
EOF
      install -o "$RW_UID" -g "$RW_GID" -m 0644 "$tmp" "$icon_path"
      rm -f "$tmp"
    fi

    log "Created desktop icon '${pretty}.desktop' (owner $rwuser)."

  done < <(lsblk -rno TYPE,UUID,FSTYPE,MOUNTPOINT | grep '^part ')
fi
